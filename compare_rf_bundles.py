"""
Script to compare bundle images generated by gso_to_bundle_RF.py using LPIPS metric.
Compares edited images against the original input to measure perceptual differences.
"""

import os
import glob
import argparse
import json
import pandas as pd
from pathlib import Path
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np

from lpips_utils import LPIPSCalculator, calculate_lpips_distance


def find_images_in_folder(folder, pattern="*.png"):
    """Find all images matching pattern in folder."""
    return sorted(glob.glob(os.path.join(folder, pattern)))


def analyze_rf_experiment(experiment_dir, lpips_net='alex', save_plots=True):
    """
    Analyze a single RF experiment directory (e.g., school_bus/prompt_0).

    Args:
        experiment_dir: Path to experiment directory
        lpips_net: LPIPS network to use ('alex' or 'vgg')
        save_plots: Whether to save comparison plots

    Returns:
        Dictionary with analysis results
    """
    results = {
        'experiment_dir': experiment_dir,
        'guidance_results': {},
        'eta_results': {},
        'statistics': {}
    }

    # Find input image
    input_image_path = os.path.join(experiment_dir, 'input_image.png')
    if not os.path.exists(input_image_path):
        print(f"Warning: No input image found in {experiment_dir}")
        return None

    # Initialize LPIPS calculator
    calc = LPIPSCalculator(net=lpips_net)

    # Analyze guidance scale variations
    guidance_dir = os.path.join(experiment_dir, 'guidance')
    if os.path.exists(guidance_dir):
        guidance_images = find_images_in_folder(guidance_dir)
        for img_path in guidance_images:
            # Extract guidance value from filename
            basename = os.path.basename(img_path)
            if '_3D_input_image.png' in basename:
                guidance_val = basename.split('_')[0]
                try:
                    distance = calc.calculate_distance(input_image_path, img_path)
                    results['guidance_results'][float(guidance_val)] = {
                        'image_path': img_path,
                        'lpips_distance': distance
                    }
                except Exception as e:
                    print(f"Error processing {img_path}: {e}")

    # Analyze eta variations
    eta_dir = os.path.join(experiment_dir, 'eta')
    if os.path.exists(eta_dir):
        eta_images = find_images_in_folder(eta_dir)
        for img_path in eta_images:
            # Extract eta value from filename
            basename = os.path.basename(img_path)
            if '_3D_input_image.png' in basename:
                eta_val = basename.split('_')[0]
                try:
                    distance = calc.calculate_distance(input_image_path, img_path)
                    results['eta_results'][float(eta_val)] = {
                        'image_path': img_path,
                        'lpips_distance': distance
                    }
                except Exception as e:
                    print(f"Error processing {img_path}: {e}")

    # Calculate statistics
    if results['guidance_results']:
        guidance_distances = [v['lpips_distance'] for v in results['guidance_results'].values()]
        results['statistics']['guidance'] = {
            'min': min(guidance_distances),
            'max': max(guidance_distances),
            'mean': np.mean(guidance_distances),
            'std': np.std(guidance_distances),
            'best_value': min(results['guidance_results'].keys(),
                            key=lambda k: results['guidance_results'][k]['lpips_distance'])
        }

    if results['eta_results']:
        eta_distances = [v['lpips_distance'] for v in results['eta_results'].values()]
        results['statistics']['eta'] = {
            'min': min(eta_distances),
            'max': max(eta_distances),
            'mean': np.mean(eta_distances),
            'std': np.std(eta_distances),
            'best_value': min(results['eta_results'].keys(),
                            key=lambda k: results['eta_results'][k]['lpips_distance'])
        }

    # Save plots if requested
    if save_plots and (results['guidance_results'] or results['eta_results']):
        plot_lpips_comparison(results, experiment_dir)

    return results


def plot_lpips_comparison(results, save_dir):
    """Create and save LPIPS comparison plots."""
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    # Plot guidance scale results
    if results['guidance_results']:
        guidance_vals = sorted(results['guidance_results'].keys())
        guidance_dists = [results['guidance_results'][v]['lpips_distance'] for v in guidance_vals]

        axes[0].plot(guidance_vals, guidance_dists, 'o-', linewidth=2, markersize=8)
        axes[0].set_xlabel('Guidance Scale', fontsize=12)
        axes[0].set_ylabel('LPIPS Distance', fontsize=12)
        axes[0].set_title('LPIPS vs Guidance Scale', fontsize=14)
        axes[0].grid(True, alpha=0.3)

        # Mark best value
        best_val = results['statistics']['guidance']['best_value']
        best_dist = results['guidance_results'][best_val]['lpips_distance']
        axes[0].plot(best_val, best_dist, 'r*', markersize=15, label=f'Best: {best_val:.1f}')
        axes[0].legend()

    # Plot eta results
    if results['eta_results']:
        eta_vals = sorted(results['eta_results'].keys())
        eta_dists = [results['eta_results'][v]['lpips_distance'] for v in eta_vals]

        axes[1].plot(eta_vals, eta_dists, 'o-', linewidth=2, markersize=8, color='green')
        axes[1].set_xlabel('Eta Value', fontsize=12)
        axes[1].set_ylabel('LPIPS Distance', fontsize=12)
        axes[1].set_title('LPIPS vs Eta', fontsize=14)
        axes[1].grid(True, alpha=0.3)

        # Mark best value
        best_val = results['statistics']['eta']['best_value']
        best_dist = results['eta_results'][best_val]['lpips_distance']
        axes[1].plot(best_val, best_dist, 'r*', markersize=15, label=f'Best: {best_val:.2f}')
        axes[1].legend()

    plt.suptitle(f'LPIPS Analysis: {os.path.basename(os.path.dirname(save_dir))}', fontsize=16)
    plt.tight_layout()

    plot_path = os.path.join(save_dir, 'lpips_analysis.png')
    plt.savefig(plot_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved plot to {plot_path}")


def analyze_all_bundles(root_dir, lpips_net='alex', output_csv=None, output_json=None):
    """
    Analyze all RF bundle experiments in the root directory.

    Args:
        root_dir: Root directory containing RF bundles (e.g., ./GSO_bundles_RF)
        lpips_net: LPIPS network to use
        output_csv: Path to save CSV results (optional)
        output_json: Path to save JSON results (optional)

    Returns:
        Dictionary with all analysis results
    """
    all_results = {}
    summary_data = []

    # Find all experiment directories
    for obj_name in os.listdir(root_dir):
        obj_dir = os.path.join(root_dir, obj_name)
        if not os.path.isdir(obj_dir):
            continue

        all_results[obj_name] = {}

        # Find all prompt directories
        prompt_dirs = sorted([d for d in os.listdir(obj_dir) if d.startswith('prompt_')])

        for prompt_dir in prompt_dirs:
            experiment_dir = os.path.join(obj_dir, prompt_dir)
            print(f"\nAnalyzing: {obj_name}/{prompt_dir}")

            results = analyze_rf_experiment(experiment_dir, lpips_net=lpips_net)
            if results:
                all_results[obj_name][prompt_dir] = results

                # Add to summary data
                summary_entry = {
                    'object': obj_name,
                    'prompt': prompt_dir,
                }

                if 'guidance' in results['statistics']:
                    summary_entry.update({
                        'guidance_min_lpips': results['statistics']['guidance']['min'],
                        'guidance_max_lpips': results['statistics']['guidance']['max'],
                        'guidance_mean_lpips': results['statistics']['guidance']['mean'],
                        'guidance_best_value': results['statistics']['guidance']['best_value'],
                    })

                if 'eta' in results['statistics']:
                    summary_entry.update({
                        'eta_min_lpips': results['statistics']['eta']['min'],
                        'eta_max_lpips': results['statistics']['eta']['max'],
                        'eta_mean_lpips': results['statistics']['eta']['mean'],
                        'eta_best_value': results['statistics']['eta']['best_value'],
                    })

                summary_data.append(summary_entry)

    # Save results
    if output_csv and summary_data:
        df = pd.DataFrame(summary_data)
        df.to_csv(output_csv, index=False)
        print(f"\nSaved CSV summary to {output_csv}")

    if output_json:
        with open(output_json, 'w') as f:
            json.dump(all_results, f, indent=2)
        print(f"Saved JSON results to {output_json}")

    # Print summary statistics
    print("\n" + "="*60)
    print("SUMMARY STATISTICS")
    print("="*60)

    if summary_data:
        df = pd.DataFrame(summary_data)

        print("\nGuidance Scale Analysis:")
        if 'guidance_mean_lpips' in df.columns:
            print(f"  Overall mean LPIPS: {df['guidance_mean_lpips'].mean():.4f}")
            print(f"  Best LPIPS across all: {df['guidance_min_lpips'].min():.4f}")
            print(f"  Most common best guidance value: {df['guidance_best_value'].mode().values[0]:.1f}")

        print("\nEta Analysis:")
        if 'eta_mean_lpips' in df.columns:
            print(f"  Overall mean LPIPS: {df['eta_mean_lpips'].mean():.4f}")
            print(f"  Best LPIPS across all: {df['eta_min_lpips'].min():.4f}")
            print(f"  Most common best eta value: {df['eta_best_value'].mode().values[0]:.2f}")

    return all_results


def compare_two_images(img1_path, img2_path, use_both_nets=True):
    """
    Simple function to compare two specific images.

    Args:
        img1_path: Path to first image
        img2_path: Path to second image
        use_both_nets: Whether to use both alex and vgg networks

    Returns:
        Comparison results
    """
    print(f"\nComparing images:")
    print(f"  Image 1: {img1_path}")
    print(f"  Image 2: {img2_path}")

    if use_both_nets:
        alex_dist, vgg_dist = calculate_lpips_distance(img1_path, img2_path, net='both')
        print(f"\nLPIPS Distance (Alex): {alex_dist:.4f}")
        print(f"LPIPS Distance (VGG):  {vgg_dist:.4f}")
        print(f"Average:               {(alex_dist + vgg_dist) / 2:.4f}")
        return {'alex': alex_dist, 'vgg': vgg_dist}
    else:
        alex_dist, _ = calculate_lpips_distance(img1_path, img2_path, net='alex')
        print(f"\nLPIPS Distance (Alex): {alex_dist:.4f}")
        return {'alex': alex_dist}


def main():
    parser = argparse.ArgumentParser(description='Compare RF bundle images using LPIPS metric')
    parser.add_argument('--bundle_dir', default='./GSO_bundles_RF', type=str,
                       help='Directory containing RF bundles')
    parser.add_argument('--lpips_net', default='alex', choices=['alex', 'vgg'],
                       help='LPIPS network to use')
    parser.add_argument('--output_csv', type=str, help='Path to save CSV summary')
    parser.add_argument('--output_json', type=str, help='Path to save detailed JSON results')
    parser.add_argument('--compare', nargs=2, metavar=('IMG1', 'IMG2'),
                       help='Compare two specific images')
    parser.add_argument('--no_plots', action='store_true',
                       help='Skip generating plots')

    args = parser.parse_args()

    if args.compare:
        # Simple comparison mode
        compare_two_images(args.compare[0], args.compare[1])
    else:
        # Full analysis mode
        if not os.path.exists(args.bundle_dir):
            print(f"Error: Bundle directory {args.bundle_dir} not found!")
            return

        # Set default output paths if not specified
        if args.output_csv is None:
            args.output_csv = os.path.join(args.bundle_dir, 'lpips_summary.csv')
        if args.output_json is None:
            args.output_json = os.path.join(args.bundle_dir, 'lpips_results.json')

        analyze_all_bundles(
            args.bundle_dir,
            lpips_net=args.lpips_net,
            output_csv=args.output_csv,
            output_json=args.output_json
        )


if __name__ == "__main__":
    main()